#Signature file v4.1
#Version 

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.Alias
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, CONSTRUCTOR, FIELD])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.AnnotateOriginal
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.AutomaticFeature
 anno 0 java.lang.Deprecated(boolean forRemoval=true, java.lang.String since="")
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.Delete
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, CONSTRUCTOR, FIELD])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.String value()

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.Inject
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[FIELD])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.InjectAccessors
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[FIELD])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<?> value()

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.KeepOriginal
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.RecomputeFieldValue
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[FIELD])
innr public final static !enum Kind
intf java.lang.annotation.Annotation
meth public abstract !hasdefault boolean disableCaching()
meth public abstract !hasdefault boolean isFinal()
meth public abstract !hasdefault java.lang.Class<?> declClass()
meth public abstract !hasdefault java.lang.String declClassName()
meth public abstract !hasdefault java.lang.String name()
meth public abstract com.oracle.svm.core.annotate.RecomputeFieldValue$Kind kind()

CLSS public final static !enum com.oracle.svm.core.annotate.RecomputeFieldValue$Kind
 outer com.oracle.svm.core.annotate.RecomputeFieldValue
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind ArrayBaseOffset
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind ArrayIndexScale
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind ArrayIndexShift
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind AtomicFieldUpdaterOffset
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind Custom
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind FieldOffset
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind FromAlias
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind Manual
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind NewInstance
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind NewInstanceWhenNotNull
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind None
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind Reset
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind StaticFieldBase
fld public final static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind TranslateFieldOffset
meth public static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind valueOf(java.lang.String)
meth public static com.oracle.svm.core.annotate.RecomputeFieldValue$Kind[] values()
supr java.lang.Enum<com.oracle.svm.core.annotate.RecomputeFieldValue$Kind>

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.Substitute
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, CONSTRUCTOR, TYPE, FIELD])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault boolean polymorphicSignature()

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.TargetClass
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE])
innr public abstract interface static NoClassNameProvider
innr public static AlwaysIncluded
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<? extends java.util.function.Function<com.oracle.svm.core.annotate.TargetClass,java.lang.String>> classNameProvider()
meth public abstract !hasdefault java.lang.Class<?> value()
meth public abstract !hasdefault java.lang.Class<?>[] onlyWith()
meth public abstract !hasdefault java.lang.String className()
meth public abstract !hasdefault java.lang.String[] innerClass()

CLSS public static com.oracle.svm.core.annotate.TargetClass$AlwaysIncluded
 outer com.oracle.svm.core.annotate.TargetClass
intf java.util.function.BooleanSupplier
meth public boolean getAsBoolean()
supr java.lang.Object

CLSS public abstract interface static com.oracle.svm.core.annotate.TargetClass$NoClassNameProvider
 outer com.oracle.svm.core.annotate.TargetClass
intf java.util.function.Function<com.oracle.svm.core.annotate.TargetClass,java.lang.String>

CLSS public abstract interface !annotation com.oracle.svm.core.annotate.TargetElement
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[METHOD, CONSTRUCTOR, FIELD])
fld public final static java.lang.String CONSTRUCTOR_NAME = "<init>"
intf java.lang.annotation.Annotation
meth public abstract !hasdefault java.lang.Class<?>[] onlyWith()
meth public abstract !hasdefault java.lang.String name()

CLSS public abstract interface java.io.Serializable

CLSS public abstract interface java.lang.Comparable<%0 extends java.lang.Object>
meth public abstract int compareTo({java.lang.Comparable%0})

CLSS public abstract interface !annotation java.lang.Deprecated
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE])
intf java.lang.annotation.Annotation
meth public abstract !hasdefault boolean forRemoval()
meth public abstract !hasdefault java.lang.String since()

CLSS public abstract java.lang.Enum<%0 extends java.lang.Enum<{java.lang.Enum%0}>>
cons protected init(java.lang.String,int)
innr public final static EnumDesc
intf java.io.Serializable
intf java.lang.Comparable<{java.lang.Enum%0}>
intf java.lang.constant.Constable
meth protected final java.lang.Object clone() throws java.lang.CloneNotSupportedException
meth protected final void finalize()
 anno 0 java.lang.Deprecated(boolean forRemoval=true, java.lang.String since="18")
meth public final boolean equals(java.lang.Object)
meth public final int compareTo({java.lang.Enum%0})
meth public final int hashCode()
meth public final int ordinal()
meth public final java.lang.Class<{java.lang.Enum%0}> getDeclaringClass()
meth public final java.lang.String name()
meth public final java.util.Optional<java.lang.Enum$EnumDesc<{java.lang.Enum%0}>> describeConstable()
meth public java.lang.String toString()
meth public static <%0 extends java.lang.Enum<{%%0}>> {%%0} valueOf(java.lang.Class<{%%0}>,java.lang.String)
supr java.lang.Object
hfds hash,name,ordinal

CLSS public abstract interface !annotation java.lang.FunctionalInterface
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE])
intf java.lang.annotation.Annotation

CLSS public java.lang.Object
cons public init()
meth protected java.lang.Object clone() throws java.lang.CloneNotSupportedException
meth protected void finalize() throws java.lang.Throwable
 anno 0 java.lang.Deprecated(boolean forRemoval=true, java.lang.String since="9")
meth public boolean equals(java.lang.Object)
meth public final java.lang.Class<?> getClass()
meth public final void notify()
meth public final void notifyAll()
meth public final void wait() throws java.lang.InterruptedException
meth public final void wait(long) throws java.lang.InterruptedException
meth public final void wait(long,int) throws java.lang.InterruptedException
meth public int hashCode()
meth public java.lang.String toString()

CLSS public abstract interface java.lang.annotation.Annotation
meth public abstract boolean equals(java.lang.Object)
meth public abstract int hashCode()
meth public abstract java.lang.Class<? extends java.lang.annotation.Annotation> annotationType()
meth public abstract java.lang.String toString()

CLSS public abstract interface !annotation java.lang.annotation.Documented
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation

CLSS public abstract interface !annotation java.lang.annotation.Retention
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.annotation.RetentionPolicy value()

CLSS public abstract interface !annotation java.lang.annotation.Target
 anno 0 java.lang.annotation.Documented()
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[ANNOTATION_TYPE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.annotation.ElementType[] value()

CLSS public abstract interface java.lang.constant.Constable
meth public abstract java.util.Optional<? extends java.lang.constant.ConstantDesc> describeConstable()

CLSS public abstract interface java.util.function.BooleanSupplier
 anno 0 java.lang.FunctionalInterface()
meth public abstract boolean getAsBoolean()

CLSS public abstract interface java.util.function.Function<%0 extends java.lang.Object, %1 extends java.lang.Object>
 anno 0 java.lang.FunctionalInterface()
meth public <%0 extends java.lang.Object> java.util.function.Function<{%%0},{java.util.function.Function%1}> compose(java.util.function.Function<? super {%%0},? extends {java.util.function.Function%0}>)
meth public <%0 extends java.lang.Object> java.util.function.Function<{java.util.function.Function%0},{%%0}> andThen(java.util.function.Function<? super {java.util.function.Function%1},? extends {%%0}>)
meth public abstract {java.util.function.Function%1} apply({java.util.function.Function%0})
meth public static <%0 extends java.lang.Object> java.util.function.Function<{%%0},{%%0}> identity()

CLSS public abstract interface !annotation org.graalvm.nativeimage.Platforms
 anno 0 java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy value=RUNTIME)
 anno 0 java.lang.annotation.Target(java.lang.annotation.ElementType[] value=[TYPE, METHOD, CONSTRUCTOR, FIELD, PACKAGE])
intf java.lang.annotation.Annotation
meth public abstract java.lang.Class<? extends org.graalvm.nativeimage.Platform>[] value()

